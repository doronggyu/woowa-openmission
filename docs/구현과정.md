## 전처리 단계
### 어노테이션 정의
- 어노테이션 등록방법은 자바 공식문서 참조해서 등록했다.
- https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html
1. Controller
```java
package minispring.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Controller {

}
```

2. Service
```java
package minispring.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;


@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Service {

}

```

3. Post, Get
```java
package minispring.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Post {
	String value();
}

```

```java
package minispring.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Get {
	String value();
}

```

4. Component - 컨트롤러, 서비스등을 원래는 다 포함하는 개념
```java
package minispring.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Component {

}

```

5. Autowried - @RequiredArgsConstructort사용해서 안썻는데 여기서는 사용해줘야함
```java
package minispring.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Autowired {

}

```

### 어노테이션 스캔
- annotation 선언없이 직접 파일 경로 입력해서 파일 스캔
- 파일 시스템 이용해서 클래스파일 검색 후 어노테이션등록된 리스트 출력

**전체 class파일 수집**
```java
package minispring.context;

import java.io.File;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;

public class ComponentScanner {

	public List<Class<?>> scan(String basePackage){

		List<Class<?>> result = new ArrayList<>();
		
		// 1) 패키지 명을 파일 경로로 변환
		String path = basePackage.replace('.', '/');
		
		// 2) ClassLoader로 경로 찾기
		URL url = Thread.currentThread()
				.getContextClassLoader()
				.getResource(path);
		
		if(url == null) {
			System.out.println("스캔 경로 오류");
			return result;
		}
		
		// 3) 실제 디렉토리
		File directory = new File(url.getFile());
		
		if(!directory.exists()) {
			return result;
		}
		
		// 4) 내부 파일들 탐색 시작
		scanDirectory(basePackage, directory, result);
		
		return result;
	}
	
	private void scanDirectory(String basePackage, File directory, List<Class<?>> result) {
		
		for(File file : directory.listFiles()) {
			
			if(file.isDirectory()) {
				// 하위 패키지 재귀 탐색
				scanDirectory(basePackage + "." + file.getName(), file, result);
			} 
			else if(file.getName().endsWith(".class")) {
				//.class 파일 -> 클래스명으로 변환
				String className = basePackage + "." + file.getName().replace(".class", "");
			
				try {
					
					Class<?> clazz = Class.forName(className);
					result.add(clazz);
					
				} catch (ClassNotFoundException e) {
					
					throw new RuntimeException("클래스 로딩 실패 : " + className, e);
				}
			}
		}
		
		
	}
}
```

**수집한 파일중 컨트롤러, 서비스등등 어노테이션 붙은 파일 필터링**
```java
package minispring.context;

import minispring.annotations.Component;
import minispring.annotations.Controller;
import minispring.annotations.Service;

import java.util.List;
import java.util.stream.Collectors;


public class AnnotationFilter {
	
	public List<Class<?>> filterForComponets(List<Class<?>> classes){
		
		return classes.stream()
				.filter(clazz -> 
						clazz.isAnnotationPresent(Component.class) ||
						clazz.isAnnotationPresent(Controller.class) ||
						clazz.isAnnotationPresent(Service.class)
				)
				.collect(Collectors.toList());
	}
}
```

**수집+필터링 및 결과**
```java
package minispring.context;

import java.util.List;

public class ApplicationContext {

	private final ComponentScanner scanner = new ComponentScanner();
	private final AnnotationFilter filter = new AnnotationFilter();
	
	public List<Class<?>> scan(String basePackage){
		
		List<Class<?>> allClasses = scanner.scan(basePackage);
		
		return filter.filterForComponets(allClasses);
	}
}

```

결과

![](https://velog.velcdn.com/images/rla405/post/c8b822c9-5023-4e95-b1c4-de31270603ef/image.png)

### Bean생성
**Bean생성 코드**
```java
package minispring.context;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class BeanFactory {

	private final Map<String, Object> beans = new HashMap<>();
	
	// Bean 후보(Class 목록들)을 받아 실제 Bean 생성
	public void registerBeans(List<Class<?>> candidates) {
		
		for(Class<?> clazz : candidates) {
			registerBean(clazz);
		}
	}
	
	// 단일 Bean 등록
	public void registerBean(Class<?> clazz) {
		
		try {
			// 1) Bean 생성규칙에 따라 이름 만들기
			String beanName = toLowerCamel(clazz.getSimpleName());
			
			// 2) 객체 생성
			Object instance = clazz.getDeclaredConstructor().newInstance();
			
			// 3) 리스트에 저장
			beans.put(beanName, instance);
		} catch ( Exception e) {
			throw new RuntimeException("Bean 생성 실패" + clazz.getName(), e);
		}
	}

	// Bean생성 규칙에 따라 이름 변환
	public String toLowerCamel(String name) {
		
		return Character.toLowerCase(name.charAt(0)) + name.substring(1);
	}
	
	// 이름으로 Bean 가져오기
	public Object getBean(String name) {
		
		return beans.get(name);
	}
	
	// 타입으로 Bean 가져오기
	public <T> T getBean(Class<T> type) {
		 
		 return (T) beans.values().stream()
	                .filter(obj -> type.isAssignableFrom(obj.getClass()))
	                .findFirst()
	                .orElseThrow(() ->
	                        new RuntimeException("해당 타입의 Bean이 존재하지 않습니다: " + type.getName())
	                );
	}
	
	public Map<String, Object> getAllBeans() {
		
		return beans;
	}
	
	
}
```

**ApplicationContext 변경**
```java
package minispring.context;

import java.util.List;

public class ApplicationContext {

	private final ComponentScanner scanner = new ComponentScanner();
	private final AnnotationFilter filter = new AnnotationFilter();
	private final BeanFactory beanFactory = new BeanFactory();
	
    public ApplicationContext(String basePackage) {

        // 1) 스캔
        List<Class<?>> allClasses = scanner.scan(basePackage);

        // 2) 어노테이션 붙은 클래스만 필터링
        List<Class<?>> beanCandidates = filter.filterForComponents(allClasses);

        System.out.println("=== Bean 후보 ===");
        beanCandidates.forEach(c -> System.out.println("- " + c.getName()));

        // 3) BeanFactory 로 Bean 생성 + 등록
        beanFactory.registerBeans(beanCandidates);

        System.out.println("=== Bean 등록 완료 ===");
    }

    public BeanFactory getBeanFactory() {
        return beanFactory;
    }
}

```

**MiniSpringApp 코드 변경**
```java
package minispring;

import java.util.List;

import minispring.context.ApplicationContext;

public class MiniSpringApp {
	public static void main(String[] args) {
		
		ApplicationContext context = new ApplicationContext("minispring.app");
		
		Object beanList = context.getBeanFactory().getAllBeans();
		
		System.out.println("Bean 리스트 : " + beanList);
	}
}

```

**결과**
![](https://velog.velcdn.com/images/rla405/post/13bdaff9-aa14-419f-af2e-a928fb84b9dc/image.png)

### 의존성 주입
**DI 코드**
```java
package minispring.context;

import java.lang.reflect.Field;
import java.util.Map;

import minispring.annotations.Autowired;

public class DIProcessor {

	public void doDI(Map<String, Object> beans) {
		
		// BeanFactory에 등록된 모든 Bean 순회
		for(Object bean : beans.values()) {
			injectDependencies(bean, beans);
		}
	}
	
	private void injectDependencies(Object bean, Map<String, Object> beans) {
		
		Class<?> clazz = bean.getClass();
		
		// Bean 내부 필드 전체 스캔
		for(Field field : clazz.getDeclaredFields()) {
			
			// @Autowired 붙은 필드만 처리
			if(field.isAnnotationPresent(Autowired.class)) {
				
				Class<?> dependencyType = field.getType();
				
				// BeanFactory에서 해당 타입의 Bean 찾기
				Object dependency = findBeanByType(beans, dependencyType);
				
				if(dependency == null) {
					throw new RuntimeException("DI 검색 실패 " + dependencyType.getName());
				}
				
				try {
					field.setAccessible(true); //private 필드도 검색 및 주입 허용
					field.set(bean, dependency);
				} catch(IllegalAccessException e) {
					throw new RuntimeException("DI 실패", e);
				}
			}
		}
	}
	
	private Object findBeanByType(Map<String, Object> beans, Class<?> type) {
		
		for(Object bean : beans.values()) {
			if(type.isAssignableFrom(bean.getClass())) {
				return bean;
			}
		}
		
		return null;
	}
}
```
**컨트롤러**
```java
package minispring.app.controller;

import minispring.annotations.Autowired;
import minispring.annotations.Controller;
import minispring.annotations.Get;
import minispring.app.service.MemberService;

@Controller
public class MemberController {

	@Autowired
	private MemberService memberService;
	
	
	@Get("/login")
	public String login() {
		
		memberService.login();
		
		return "login";
	}
}

```

**서비스**
```java
package minispring.app.service;

import minispring.annotations.Service;

@Service
public class MemberServiceImpl implements MemberService {

	public void login() {
		System.out.println("로그인 서비스 동작");
	}
}

```

**결과**

![](https://velog.velcdn.com/images/rla405/post/36d5f4a4-1b08-47b3-8091-2b57c9ac1fb1/image.png)

**ApplicationContext, MiniSpringApp 변경은 생략**


### HandlerMapping 등록
**클래스,메소드 저장객체**
```java
package minispring.web;

import java.lang.reflect.Method;

public class HandlerMethod {

	private final Object bean;
	private final Method method;
	
	public HandlerMethod(Object bean, Method method) {
		this.bean = bean;
		this.method = method;
	}
	
	public Object getBean() {
		return bean;
	}
	
	public Method getMethod() {
		return method;
	}
}

```

**url, HandlerMethod 맵핑**
```java
package minispring.web;

import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;

import minispring.annotations.Controller;
import minispring.annotations.Get;
import minispring.annotations.Post;

public class HandlerMapping {

	private final Map<String, HandlerMethod> handlerMap = new HashMap<>();
	
	public HandlerMapping(Map<String, Object> beans) {
		initHandlerMapping(beans);
	}
	
	public HandlerMethod getHandler(String url) {
		return handlerMap.get(url);
	}
	
	private void initHandlerMapping(Map<String, Object> beans) {
		
		for(Object bean : beans.values()) {
			
			Class<?> clazz = bean.getClass();
			
			if(!clazz.isAnnotationPresent(Controller.class)) {
				continue;
			}
			
			for(Method method : clazz.getDeclaredMethods()) {
				
				if(method.isAnnotationPresent(Get.class)) {
					String url = method.getAnnotation(Get.class).value();
					handlerMap.put(url, new HandlerMethod(bean, method));
				}
				
				if(method.isAnnotationPresent(Post.class)) {
					String url = method.getAnnotation(Post.class).value();
					handlerMap.put(url, new HandlerMethod(bean, method));
				}
			}
		}
		
	   System.out.println("=== HandlerMapping 등록 완료 ===");
        handlerMap.forEach((url, hm) ->
            System.out.println(url + " → " 
            + hm.getMethod().getDeclaringClass().getSimpleName() 
            + "." + hm.getMethod().getName()));
	}
}

```

### URL에 따라 메소드 실행
```java
package minispring.web;

import java.lang.reflect.Method;

public class DispatcherServlet {

	private final HandlerMapping handlerMapping;
	
	public DispatcherServlet(HandlerMapping handlerMapping) {
		this.handlerMapping = handlerMapping;
	}
	
	public void handleRequest(String url) {
		
		HandlerMethod handler = handlerMapping.getHandler(url);
		
		if(handler == null) {
			System.out.println("매핑된 핸들러 없음");
			return;
		}
		
		Object controller = handler.getBean();
		Method method = handler.getMethod();
		
		try {
			
			Object returnValue = method.invoke(controller);
			
		} catch (Exception e) {
			throw new RuntimeException("핸들러메서드 실행 실패", e);
		}
	}
}

```

### 서버 만들기
```java
package minispring.web;

import java.io.IOException;
import java.io.OutputStream;
import java.net.InetSocketAddress;

import com.sun.net.httpserver.HttpServer;
import com.sun.net.httpserver.HttpHandler;
import com.sun.net.httpserver.HttpExchange;


public class MiniWebServer {

	private final DispatcherServlet dispatcher;
	
	public MiniWebServer(DispatcherServlet dispatcher) {
		
		this.dispatcher = dispatcher;
	}
	
	public void start(int port) throws IOException {
		
		HttpServer server = HttpServer.create(new InetSocketAddress(port), 0);
		
		server.createContext("/", new HttpHandler() {
			
			@Override
			public void handle(HttpExchange exchange) throws IOException {
				
				String url = exchange.getRequestURI().getPath();
				
				Object result = dispatcher.handleRequest(url);
				
				String response = String.valueOf(result);
				
				exchange.sendResponseHeaders(200, response.getBytes().length);
				
				OutputStream os = exchange.getResponseBody();
				os.write(response.getBytes());
				os.close();
			}
		});
		
		server.start();
	}
}

```

**결과**
![](https://velog.velcdn.com/images/rla405/post/c00d5af5-42aa-45e0-9c56-1ccdf56bebb8/image.png)


